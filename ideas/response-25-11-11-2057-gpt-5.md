You’re feeling the pain because “exporting/templating” are being expressed as global UI state (exportMode/exporting) rather than as an ephemeral rendering concern. That forces normal interactive components (cards/images/grid/cursors) to branch on that state, which is brittle and leaks into everything.

A cleaner, extensible approach is:
- Separate the scene into layers and keep “interactive/UI chrome” out of the “document” layer.
- Provide a small Capture/Render service that renders only the document layer into a RenderTexture with an explicit “profile” (what to include, how to crop, how to scale), without touching global state or re-rendering React.
- Query the scene for “what to include” via a strategy (everything, current client selection, a specific set of ids) and compute bounds from the objectSizes you already track.
- Do not depend on store toggles to hide/hack visual states; selection/hover accents must live in an overlay layer that is naturally excluded from capture.

Below is a step-by-step plan and some broad-stroke pseudo code to get there.

Step 1: Introduce a sane scene/layer graph
Goal: export should only render “content,” not grid/cursors/selection/hover.

- Root containers
  - stageRoot: Container
  - camera: Container (holds camera transform)
- Layers (children of camera unless noted)
  - backgroundLayer (grid, guides)
  - documentLayer (cards, images, stamps; only the content you want in exports)
  - selectionLayer (selection rectangles, resize handles, multi-select box)
  - interactionLayer (drag previews if any; overlays that are camera-scaled)
  - cursorsLayer (may be outside camera so they don’t scale, or you can 1/scale them manually)
  - hudLayer (DOM overlays; not PIXI)

Important: selection highlights and hover effects should be drawn in selectionLayer (or interactionLayer), not inside the card/image content mesh. That way export just renders documentLayer and naturally excludes highlights.

Example wiring (once, at canvas init):
- stageRoot.addChild(camera)
- camera.addChild(backgroundLayer, documentLayer, selectionLayer, interactionLayer)
- stageRoot.addChild(cursorsLayer) // optional, screen-space
- DOM overlays render above the PIXI canvas

Step 2: Move selection/hover visuals out of content components
Right now CardBox uses isSelected/isHovering to change the actual card mesh. Split that:

- CardContent (document layer): renders the card fill/stroke and text/content. No selection/hover state. Deterministic output.
- CardSelectionOverlay (selection layer): draws the blue outline/halo/resize affordances when selected/hovered.

Do the same for images/stamps. The grid goes to backgroundLayer. Cursors/multi-select rectangle go to cursorsLayer/selectionLayer.

This eliminates the need to toggle exporting/isTemplating flags in components and prevents export-only states from leaking into interactive rendering.

Step 3: Introduce a single CaptureService (no global store state)
A small service class encapsulates the logic for export/preview, with zero reliance on exportMode/exporting in the store. It operates purely on PIXI containers and the current canvas transform.

Core ideas:
- Render only the documentLayer into a RenderTexture
- Temporarily adjust documentLayer’s transform to “frame” the content area you want (selection or everything), then restore it
- Compute bounds from objectSizes to crop exactly the area you want
- Oversample and downscale if you want higher-quality downscaling when scale < 1

Types (example):
```ts
type LayerId = 'background' | 'document' | 'selection' | 'interaction' | 'cursors';

type SelectionStrategy =
  | { kind: 'everything' }
  | { kind: 'clientSelection'; clientId: string }
  | { kind: 'ids'; ids: string[] }
  | { kind: 'rect'; x: number; y: number; width: number; height: number };

type IncludeType = 'card' | 'image' | 'stamp';

type Aspect = { mode: 'fit' | 'cover'; ratio: number };

type CaptureProfile = {
  selection: SelectionStrategy;
  includeTypes?: IncludeType[];         // e.g. ['card', 'image']
  padding?: number;                     // px in world units
  aspect?: Aspect;                      // e.g. {mode:'fit', ratio: 16/9}
  scale?: number;                       // desired raster scale (base), defaults to devicePixelRatio
  oversample?: number;                  // e.g. 2 for oversample x2 then downscale
  background?: 'transparent' | { color: number };
};
```

Service outline:
```ts
class CaptureService {
  constructor(
    private app: PixiApp,
    private layers: { documentLayer: Container },
    private camera: TransformLike, // or Container
    private getObjectSizes: (id: string) => [number, number] | undefined,
    private listExportables: () => Array<{ id: string; type: IncludeType; x: number; y: number }>
  ) {}

  async capture(profile: CaptureProfile): Promise<string> {
    const exportables = this.query(profile.selection, profile.includeTypes);
    if (exportables.length === 0) return Promise.resolve(null);

    const bounds = this.computeBounds(exportables, profile.padding);
    const framed = this.applyAspect(bounds, profile.aspect); // returns {x,y,width,height}

    const prev = this.saveTransform(this.layers.documentLayer);
    this.applyCaptureTransform(framed);

    const oversample = profile.oversample ?? 1;
    const baseScale = profile.scale ?? (window.devicePixelRatio || 1);
    const resolution = baseScale * oversample;

    const rt = RenderTexture.create({
      width: framed.width,
      height: framed.height,
      resolution,
    });

    this.app.renderer.render({ container: this.layers.documentLayer, target: rt });

    this.restoreTransform(this.layers.documentLayer, prev);

    let base64 = await this.app.renderer.extract.base64(rt);

    if (oversample > 1) {
      base64 = await this.downscaleBase64(base64, 1 / oversample); // same bilinear you already have
    }

    return base64;
  }

  private query(selection: SelectionStrategy, include?: IncludeType[]) {
    // uses store data but read-only; no writes
    const all = this.listExportables();
    // filter by includeTypes and selection strategy
    // return elements with geometry (x,y) and getObjectSizes() for width,height
  }

  private computeBounds(
    items: Array<{ id: string; x: number; y: number }>
    , padding: number | undefined
  ) {
    // minX, minY, maxX, maxY from items + their object sizes
  }

  private applyAspect(bounds: {x:number;y:number;width:number;height:number}, aspect?: Aspect) {
    if (!aspect) return bounds;
    // expand width or height so that width/height matches aspect.ratio using aspect.mode 'fit' or 'cover'
  }

  private saveTransform(container: Container) {
    return {
      x: container.position.x,
      y: container.position.y,
      scaleX: container.scale.x,
      scaleY: container.scale.y,
      rotation: container.rotation,
    };
  }

  private applyCaptureTransform(framed: {x:number;y:number;width:number;height:number}) {
    // We want documentLayer to render as if the camera offset and zoom are neutralized,
    // and top-left of framed rect maps to (0,0) in the render target.
    // If camera has position P and scale S:
    //  - translate document by (-framed.x - camera.position.x / camera.scale.x, -framed.y - camera.position.y / camera.scale.y)
    //  - scale by (1 / camera.scale.x)
  }

  private restoreTransform(container: Container, prev: ReturnType<this['saveTransform']>) {
    container.position.set(prev.x, prev.y);
    container.scale.set(prev.scaleX, prev.scaleY);
    container.rotation = prev.rotation;
  }

  private async downscaleBase64(base64: string, scale: number) {
    // reuse your base64ToImageData + downscaleImageBilinear + imageDataToBase64
  }
}
```

Notes:
- We render only documentLayer, so grid/cursors/selection/hover never need to be hidden.
- We temporarily adjust only the documentLayer transform (not the entire stage), and we restore it immediately after.
- No store updates. No React re-render.

Step 4: Provide a small scene registry/query
You already maintain objectSizes in the store. Add a read-only scene query util to avoid duplication:

- A function that returns exportable elements from store:
  - includeTypes: cards/images/stamps only
  - selection strategies:
    - everything: all exportable objects
    - clientSelection: those selectedBy or dragLock.lockedTo = clientId
    - ids: explicit list

```ts
function listExportablesFromStore(state: CanvasState): Array<{ id: string; type: IncludeType; x: number; y: number }> {
  // filter isCanvasCard/image/stamp from state.objects, map to minimal descriptors
}
```

Step 5: A tiny React hook to get a CaptureService instance
You need stable refs to the app, documentLayer, camera.

```ts
export function useCaptureService(
  appRef: RefObject<PixiApp | null>,
  layersRef: RefObject<{ documentLayer: Container }>,
  camera: Transform
) {
  const getObjectSizes = useCanvasStore(s => s.objectSizes);
  const listExportables = useCanvasStore(s => () => listExportablesFromStore(s));

  const service = useMemo(() => {
    if (!appRef.current || !layersRef.current) return null;
    return new CaptureService(
      appRef.current,
      { documentLayer: layersRef.current.documentLayer },
      camera,
      (id: string) => getObjectSizes[id],
      listExportables
    );
  }, [appRef.current, layersRef.current, camera, getObjectSizes, listExportables]);

  return service;
}
```

Step 6: Implement preview and export without touching store
- Export dialog: call captureService.capture with selection: everything or clientSelection, includeTypes, scale = user scale/devicePixelRatio, aspect: undefined, etc.
- Template dialog: call captureService.capture with selection: clientSelection, includeTypes: ['card','image'], aspect: { mode:'fit', ratio: 16/9 }, oversample: 1–2 as needed.

No global state toggles. No exporting flags.

Example usage:
```ts
const capture = useCaptureService(appRef, layersRef, transform);

useEffect(() => {
  if (!capture || !open) return;
  let cancelled = false;
  capture.capture({
    selection: { kind: hasSelection ? 'clientSelection' : 'everything', clientId },
    includeTypes: ['card','image'],
    aspect: { mode: 'fit', ratio: 16 / 9 }, // for template previews
    scale: window.devicePixelRatio,
    oversample: 1
  }).then(img => {
    if (!cancelled) setPreview(img);
  });
  return () => { cancelled = true; };
}, [capture, open, clientId, hasSelection]);
```

Step 7: Remove CanvasExportMode/exporting from the store
- They’re no longer needed.
- Components no longer branch on exporting or exportMode; export conditions are completely outside React rendering.
- If you need to show “busy” or “exporting…” UI, keep that as local component state in the dialog that’s calling captureService.

Step 8: Migration details
- Start by extracting selection visuals from CardBox/Image/Stamp into a separate overlay component and mount it in selectionLayer. That is the biggest win.
- Create and wire layers once, and give React children a way to mount into the right layer. With @pixi/react you can pass a container prop or use a context that returns the right parent.
- Replace current render() util with CaptureService. Keep your bilinear downscale for oversample.
- Delete exportMode/exporting from the store after the above works.

Step 9: Extensibility built-in
This design scales to new cases without leaking flags:
- PDF export: a new profile with a known DPI, background: white, page aspect ratio, tiling across multiple pages if content exceeds limits.
- “Thumbnail” generation anywhere: a profile with aspect: fit 16/9, scale to 2x, includeTypes limited to cards/images.
- Watermarking: add a simple post-process step that composites a watermark canvas over the extracted base64.
- Transparent exports: background: transparent, includeTypes that exclude any background fill.

Why this is better
- No global reactivity to transient export states. Export/preview becomes a pure function of the scene graph + options.
- Layers let you reason about what’s part of the “document” vs UI. Export is “render the document layer,” done.
- Selection/hover are presentation concerns, not content. Moving them to an overlay removes if/else hooks from content and avoids flicker.
- The capture profile approach gives you a single API for all current and future rendering needs.

Optional niceties (if needed later)
- Serialize capture requests through a small queue to avoid overlapping renders when options change rapidly.
- Cache last preview by a key (e.g., a hash of selection + sizes + profile) if previews are requested frequently.
- Provide a unified “Camera” abstraction so both interactive panning/zooming and capture transform can be reasoned about with the same math.

Summary of concrete steps to implement incrementally
1) Introduce layers: background, document, selection, interaction, cursors. Move existing elements accordingly.
2) Split selection/hover visuals from content meshes into overlays in selection/interaction layers.
3) Implement CaptureService to render only documentLayer with selection/aspect/scale options.
4) Replace uses of render()/exportMode/exporting in Export and Template dialogs with captureService.capture(...).
5) Remove exportMode/exporting from the store and clean up component branches that referenced them.
6) Optional: add oversample-based downscale in the service for low-scale previews.

After this, you’ll have a stable, composable “rendering pipeline” in a single place, and your canvas stays interactive with no weird side effects while you capture previews/exports.